---
title: "Introduction to the binosim R Package"
author: "Amrit Tiwana"
format: 
  revealjs:
    slide-number: true
    transition: slide
editor: visual
---

## Table of Contents

-   Motivation behind making the package
-   Overview of the package
-   Example

## Motivation

In Week 9, we learned how to conduct a simulation study. Is there a way we can simplify this code?

```{r}
#| echo: true
#| eval: false
## set simulation parameters
n <- 100 # sample size
pz <- 0.2 # probability of Z = 1
alpha0 <- 0 # logit probability of x = 1 in non-smokers (z = 0)
alpha1 <- 1 # log odds ratio of x = 1 in smokers (z = 1) vs non-smokers
beta0 <- -3 # logit probability of y = 1 in non-coffee drinkers (x = 0) and non-smoke
beta1 <- 0
beta2 <- 2
simnum <- 1000 # number of iterations to run in the simulation
# empty vectors to store the values
unadj.p <- adj.p <- rep(NA, simnum)
for(s in 1:simnum){
## generate confounder Z from a binomial distribution
z <- rbinom(n, size = 1, prob = pz)
## compute probability of observing X = 1 from the inverse logit function
px <- exp(alpha0 + alpha1 * z) / (1 + exp(alpha0 + alpha1 * z))
## randomly generate binary variable X from the above probability
x <- rbinom(n, size = 1, prob = px)
## repeat above to randomly generate binary variable Y
py <- exp(beta0 + beta1 * x + beta2 * z) / (1 + exp(beta0 + beta1 * x + beta2 * z))
y <- rbinom(n, size = 1, prob = py)
## combine three random variables into a data frame
dat <- data.frame(lung = y, coffee = x, smoke = z)
## fit unadjusted logistic regression model
unadj.mod <- glm(lung ~ coffee, data = dat, family = "binomial")
unadj.coef <- summary(unadj.mod)$coef
## fit adjusted logistic regression model
adj.mod <- glm(lung ~ coffee + smoke, data = dat, family = "binomial")
adj.coef <- summary(adj.mod)$coef
## save p-values for coffee from both models in a vector
unadj.p[s] <- unadj.coef[2,4]
adj.p[s] <- adj.coef[2,4]
## show simulation progress
print(s)
}
## calculate the type 1 error rate from each model
mean(ifelse(unadj.p < 0.05, 1, 0))
mean(ifelse(adj.p < 0.05, 1, 0))
```

::: footer
Code provided by Aya Mitani.
:::

## Motivation

Why should we try to simplify code?

-   Becomes easier to share and explain the code to others, promoting collaboration and reproducibility.

-   Reduces the chances of errors during coding.

-   Reduces debugging time.

## Motivation

``` {.r code-line-numbers="13-23"}
## set simulation parameters
n <- 100 # sample size
pz <- 0.2 # probability of Z = 1
alpha0 <- 0 # logit probability of x = 1 in non-smokers (z = 0)
alpha1 <- 1 # log odds ratio of x = 1 in smokers (z = 1) vs non-smokers
beta0 <- -3 # logit probability of y = 1 in non-coffee drinkers (x = 0) and non-smoke
beta1 <- 0
beta2 <- 2
simnum <- 1000 # number of iterations to run in the simulation
# empty vectors to store the values
unadj.p <- adj.p <- rep(NA, simnum)
for(s in 1:simnum){
## generate confounder Z from a binomial distribution
z <- rbinom(n, size = 1, prob = pz)
## compute probability of observing X = 1 from the inverse logit function
px <- exp(alpha0 + alpha1 * z) / (1 + exp(alpha0 + alpha1 * z))
## randomly generate binary variable X from the above probability
x <- rbinom(n, size = 1, prob = px)
## repeat above to randomly generate binary variable Y
py <- exp(beta0 + beta1 * x + beta2 * z) / (1 + exp(beta0 + beta1 * x + beta2 * z))
y <- rbinom(n, size = 1, prob = py)
## combine three random variables into a data frame
dat <- data.frame(lung = y, coffee = x, smoke = z)
## fit unadjusted logistic regression model
unadj.mod <- glm(lung ~ coffee, data = dat, family = "binomial")
unadj.coef <- summary(unadj.mod)$coef
## fit adjusted logistic regression model
adj.mod <- glm(lung ~ coffee + smoke, data = dat, family = "binomial")
adj.coef <- summary(adj.mod)$coef
## save p-values for coffee from both models in a vector
unadj.p[s] <- unadj.coef[2,4]
adj.p[s] <- adj.coef[2,4]
## show simulation progress
print(s)
}
## calculate the type 1 error rate from each model
mean(ifelse(unadj.p < 0.05, 1, 0))
mean(ifelse(adj.p < 0.05, 1, 0))
```

## Overview

binosim returns a data frame of binary data based on the parameters of a logistic regression model.

```{r}
#| echo: true
#| eval: false
sim_data <- binosim(n = 10, px = 0.4, baseprob = 0.1, or = 2)
```
::: {.fragment}
| Argument   | Description                |
|------------|----------------------------|
| `n`        | Sample size.               |
| `px`       | Probability of x.          |
| `baseprob` | Baseline probability of Y. |
| `or`       | True odds ratio.           |
:::

## Overview

This is how the binosim function was created.

```{r}
#| echo: true
#| eval: true
# Simulate binary data from simple logistic regression
binosim <- function(n, px, baseprob, or) {
  # Generate predictor variable X from a binomial distribution
  x <- rbinom(n, size = 1, prob = px)
  # Convert baseline probability to log-odds using the logit function
  baseprob <- log((baseprob) / (1 - baseprob))
  # Calculate the log-odds using baseline probability as the intercept
  logodds <- baseprob + log(or) * x
  # Calculate the probability of success for Y given the log-odds
  py <- exp(logodds) / (1 + exp(logodds))
  # Generate outcome variable Y from a binomial distribution
  y <- rbinom(n, size = 1, prob = py)
  # Combine X and Y variables into a data frame
  sim_data <- data.frame(y = y, x = x)
  # Return the simulated data
  return(sim_data)
}
```

## Example

Let's conduct a simulation study using binosim.

```{r}
#| echo: true
#| eval: true
set.seed(123)
true_or <- 2
simnum <- 1000
est <- se <- p_value <- or <- lower_ci <- upper_ci <- in_ci <- rep(NA,simnum)
for (s in 1:simnum){
  sim_data <- binosim(1000, 0.5, 0.1, 2)
  mod <- glm(y ~ x, data = sim_data, family = "binomial")
  coef <- summary(mod)$coef
  est[s] <- coef[2,1]
  se[s] <- coef[2,2]
  p_value[s] <- coef[2,4]
  or[s] <- exp(coef[2,1])
  lower_ci[s] <- exp(confint(mod)[2,1])
  upper_ci[s] <- exp(confint(mod)[2,2])
  # Check if the true odds ratio is within the confidence interval
  in_ci[s] <- true_or >= lower_ci[s] & true_or <= upper_ci[s]
}
```

## Example

```{r}
#| echo: true
#| eval: true
# Calculate empirical coverage
mean(in_ci)
```

The simulated confidence intervals covered the true odds ratio approximately 94.3% of the time.

## Example

```{r}
#| echo: true
#| eval: true
# Plot the distribution of the ORs and display plot
hist(or, main = "Distribution of Odds Ratios", xlab = "Odds Ratio", col = "lightblue", border = "black")
# Add a vertical line for the true OR
abline(v = 2, col = "red", lty = 2)
```

## Conclusion and Future Steps

-   This package creates an efficient way to generate binary data from a logistic model.

-   The generated data can be used for conducting simulation studies.

-   Future work will look into adding a confounder Z into the function.

## Questions? {.center}
